## 概述

## 实现原理及示例

### 新建注解类
1. 注解在Java中，与类、接口、枚举类似，因此其声明语法基本一致，只是所使用的关键字有所不同`@interface`。**在底层实现上，所有定义的注解都会自动继承java.lang.annotation.Annotation接口**。

2. 注解类型的实现部分：
根据我们在自定义类的经验，在类的实现部分无非就是书写构造、属性或方法。但是，在自定义注解中，其实现部分**只能定义**一个东西：**注解类型元素（annotation type element）**。
- 定义注解类型元素时需要注意如下几点：
- 访问修饰符必须为public，不写默认为public；
- 该元素的类型只能是基本数据类型、String、Class、枚举类型、注解类型（体现了注解的嵌套效果）以及上述类型的一位数组；
- 该元素的名称一般定义为名词，如果注解中只有一个元素，请把名字起为value（后面使用会带来便利操作）；
- ()不是定义方法参数的地方，也不能在括号中定义任何参数，仅仅只是一个特殊的语法；
- default代表默认值，值必须和第2点定义的类型一致；
- 如果没有默认值，代表后续使用注解时必须给该类型元素赋值。
3. 专门用来修饰注解的注解叫做元注解，元注解有以下几种：
- @Target : 是专门用来限定某个自定义注解能够被应用在哪些Java元素上面的
- @Retention : 用来修饰自定义注解的生命力(即注明注解在那个生命周期生效)
- @Documented : 用来指定自定义注解是否能随着被定义的java文件生成到JavaDoc文档当中
- @Inherited : 指定某个自定义注解如果写在了父类的声明部分，那么子类的声明部分也能自动拥有该注解。@Inherited注解只对那些@Target被定义为ElementType.TYPE的自定义注解起作用。
```java
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface ScheduledTask {
  /** 任务名称 */
  String name();

  String group();

  /** 任务描述 */
  String description();

  /** 执行周期 */
  String scheduleRate();

  /** 定时表达式 */
  String cron();

  /** 自定义参数 */
  String params();

  /** 失败重试次数 */
  int failureNum();

  /** 失败重试间隔 */
  int failureInterval();
}
```

### 新建后置处理器（BeanPostProcessor）
BeanPostProcessor接口，也叫做后置处理器，作用是在Bean对象实例化和依赖注入完成以后，在调用初始化方法的前后处理我们自己的逻辑。该接口中定义了两个方法：

| 方法 | 说明 |
| ---- | ---- |
|   postProcessBeforeInitialization   | 在调用初始化方法之前执行此方法，一般此方法用于在初始化方法之前加入自己的初始化操作（比如填充属性） |
|  postProcessAfterInitialization    | 在调用初始化方法之后执行此方法 |

> 需要注意的是，这两个方法均不可返回null，如果返回null则在之后的初始化方法中将报空指针异常或者通过getBean()方法获取不到bean的示例对象，因为后置处理器从IOC容器取出的bean实例在返回null的情况下没有放回到Ioc容器中。

```java
import java.util.Objects;
import org.springframework.aop.framework.AopProxyUtils;
import org.springframework.beans.factory.config.BeanPostProcessor;
import org.springframework.core.annotation.AnnotationUtils;

public class ScheduledTaskBeanPostProcessor implements BeanPostProcessor {

  @Override
  public Object postProcessAfterInitialization(Object bean, String beanName) {
    Class<?> targetClass = AopProxyUtils.ultimateTargetClass(bean);
    //    获取自定义注解
    ScheduledTask annotation = AnnotationUtils.getAnnotation(targetClass, ScheduledTask.class);
    //    如果自定义注解不为空，则表示此类被注解
    if (Objects.nonNull(annotation)) {
      //     从注解中获取属性，进行后续处理

    }
    return bean;
  }
}
```
### 新建导入类（ImportSelector）
ImportSelector接口是spring中导入外部配置的核心接口，主要作用是手机要导入的配置类。在spring boot中一般是和@Import注解一起使用，以实现自动配置。
该接口只有一个方法selectImports，通过参数可以获取到@Import标注的类的各种信息（包括类名，实现的接口，父类，添加的其他注解信息），通过这些信息可以辅助我们选择我们需要需要导入类的类名，该方法的返回值是需要导入类的完整类名数组。
> 需要导入的类意思是定义Spring Bean 放到Spring IOC容器中.
```java
import org.springframework.context.annotation.ImportSelector;
import org.springframework.core.type.AnnotationMetadata;
import org.springframework.lang.NonNull;

 public class ScheduledTaskImportSelector implements ImportSelector {

  @NonNull
  @Override
  public String[] selectImports(AnnotationMetadata annotationMetadata) {
    return new String[] {ScheduledTaskBeanPostProcessor.class.getName()};
  }
 }
```
### 新建EnableXXX注解
EnableXXX注解与一般的自定义注解类似，主要的不同是在此注解上我们使用了@Import注解标注，@Import注解的主要作用是与上文中的ImportSelector配合，实现Spring Bean的导入，以实现自动配置。
```java
import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;
import org.springframework.context.annotation.Import;

@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Import(ScheduledTaskImportSelector.class)
@Documented
public @interface EnableScheduledTask {}
```

